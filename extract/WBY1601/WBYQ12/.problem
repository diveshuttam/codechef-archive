{
    "status": "success",
    "problem_status": "unattempted",
    "problem_tester": null,
    "body": "<p>In a country, all stations are denoted by numbers. The details of the stations are stored in two layers. The upper layer works as an \u201cexpress lane\u201d which connects only main outer stations (referred to as outer stations), and the lower layer works as a \u201cnormal lane\u201d which connects every station. All the stations follow continuous numbering. The outer stations split the stations into 4 parts, in other words, one-fourth of the number of stations in each part.<br /> Write a code to display if a given station is found or not. If the station is found, also display which outer station it lies under.<br />\n<br /><br />\nThe stations are numbered from 1 to n, the outer stations being 1, n/4, n/2, 3n/4, and n.<br /><br />\nExample: if there are 40 stations, stations 1-9 fall under outer station 1, 10-19 under outer station 10, 20-29 under outer station 20, 30-39 under outer station 30 and 40 under outer station 40.<br /><br />\n</p>\n<p><b>NOTE:</b>The number of stations is always divisible by 4.</p>\n<h3>Input</h3>\n<p>\nThe input contains 2 integer values:</p>\n<ul>\n<li> <b>n</b>, the number of stations,\n</li><li><b>s</b>, the station to be searched\n</li></ul>\n\n<h3>Output</h3>\n<p>\n<ul>\n<li>'Station found!' <b>OR</b> 'Station Not found!'<br /></li></ul></p>\n<li>if 'Station Found' the value of the corresponding outer station number <br />\n<p>\u00a0</p>\n<h3>Constraints</h3>\n<ul>\n<li><b>1</b> \u2264 <b>n</b> \u2264 <b>1000</b></li>\n</ul>\n<h3>Example</h3>\n<pre><b>Input:</b>\n100<br />\n25<br />\n<b>Output:</b>\nStation Found!<br />\n25\n</pre><pre><b>Input:</b>\n101<br />\n250<br />\n<b>Output:</b>\nInvalid Number of Stations.\n</pre><pre><b>Input:</b>\n104<br />\n250<br />\n<b>Output:</b>\nStation Not found!\n</pre><h3>\nCode:</h3>\n<p>import java.util.*;</p>\n<p>public class Main {<br /><br />\n    private static Node Head = null;<br /><br />\n    private static Node Tail = null;<br /><br />\n    private static Node Current = null;<br /><br />\n\t<br /><br />\n<br /><br />\n    private static Node quarter = null;<br /><br />\n    private static Node half = null;<br /><br />\n\t<br /><br />\n    public static void main(String[] args) {<br /><br />\n    \tScanner scan = new Scanner(System.in);<br /><br />\n    \t<br /><br />\n    \tint ListCount = scan.nextInt();<br /><br />\n        if(ListCount%4!=0){<br /><br />\n        \tSystem.out.println(\"Invalid Number of Stations.\");<br /><br />\n\texit(0);<br /><br />\n<br /><br />\n        }<br /><br />\n        int m=ListCount/2;<br /><br />\n        int n=ListCount/4;<br /><br />\n\t\t<br /><br />\n<br /><br />\n        for (int i = 1; i &lt;= ListCount; i++) {<br /><br />\n            Node newNode = new Node();<br /><br />\n            newNode.data = i;<br /><br />\n\t\t\t<br /><br />\n\t\t<br /><br />\n<br /><br />\n            if (Head == null) { <br /><br />\n                Head = newNode; <br /><br />\n                Tail = newNode; <br /><br />\n                Current = newNode;<br /><br />\n\t\t\t\t<br /><br />\n                quarter = newNode;<br /><br />\n                half = newNode;<br /><br />\n            }<br /><br />\n            else {<br /><br />\n                Current.next = newNode;<br /><br />\n                newNode.prev = Current;<br /><br />\n\t\t\t\t<br /><br />\n<br /><br />\n                if ((i % m) == 0) { <br /><br />\n                    newNode.prevQuarter = quarter; <br /><br />\n                    quarter.nextQuarter = newNode;<br /><br />\n\t<br /><br />\n                }<br /><br />\n<br /></p>\n<p>                if ((i % n) == 0) { <br /><br />\n                    newNode.prevHalf = half; <br /><br />\n                    half.nextHalf = newNode;<br /><br />\n\t\t\t<br /><br />\n                }<br /><br />\n\t\t\t<br /><br />\n                <br /><br />\n            }\t<br /><br />\n        }<br /><br />\n\t\t<br /><br />\n<br /><br />\n\t\tint s=scan.nextInt();<br /><br />\n             FindNumber(s);\t<br /><br />\n    }<br /><br />\n\t<br /><br />\n\t<br /><br />\n    public static void FindNumber(int num) {<br /><br />\n        Node currentNode = Head;<br /><br />\n        Node parentNode=Head;<br /><br />\n        boolean Found = true;<br /><br />\n\t\t<br /><br />\n        while (currentNode != null) {<br /><br />\n\tparentNode=currentNode;<br /><br />\n            <br /><br />\n            if (currentNode.data != num) {<br /><br />\n                if  (currentNode.nextHalf.data &lt;= num) { <br /><br />\n                \tcurrentNode = currentNode.nextHalf;<br /><br />\n                \tparentNode=currentNode;}<br /><br />\n                else if  (currentNode.nextQuarter.data &lt;= num) {<br /><br />\n                \tcurrentNode = currentNode.nextQuarter;<br /><br />\n                \t<br /><br />\n                }<br /><br />\n                else { currentNode.next = currentNode;}<br /><br />\n            }<br /><br />\n            else {<br /><br />\n                Found = true;<br /><br />\n                break;<br /><br />\n            }<br /><br />\n        }<br /><br />\n\t\t<br /><br />\n        if (Found) { System.out.println(\"Station Found!\\n\" + parentNode); }<br /><br />\n        else { System.out.println(\"Station Not found!\"); }<br /><br />\n    }<br /><br />\n}<br /><br />\n<br /></p>\n<p>class Node {<br /><br />\n    int data;<br /><br />\n    private Node next = null;<br /><br />\n    private Node prev = null;<br /></p>\n<p>    private Node nextHalf = null;<br /><br />\n    private Node prevHalf = null;<br /></p>\n<p>    private Node nextQuarter = null;<br /><br />\n    private Node prevQuarter = null;<br /><br />\n}<br /></p>\n<hr />\n<h3>Steps to be followed</h3>\n<p>    1. Read the given description carefully and understand the problem.<br /><br /></p>\n<p>    2. Analyze the code given in the problem and find bugs(errors) in these codes..<br /><br /></p>\n<p>    3. The given code can be copied and compiled in the CodeChef online compiler (<a href=\"https://www.codechef.com/ide\">https://www.codechef.com/ide</a>).<br /><br /></p>\n<p>    4. Once the bugs are eliminated from the code, the clean code can be submitted as the solution to the problem..<br /><br /></p>\n<p>    5. The solution should be a debugged version of the code provided and must satisfy the test cases to be accepted..<br /><br /></p>\n<p><b>All the best!!</b></p>\n</li>",
    "category_name": "main",
    "user": {
        "username": ""
    },
    "date_added": "17-02-2016",
    "is_direct_submittable": false,
    "contest_name": "Whats Bugging You Qualifiers",
    "languages_supported": "JAVA",
    "todo": false,
    "time": {
        "view_start_date": 1455780600,
        "end_date": 1455793200,
        "practice_submission_allowed": true,
        "visible_start_date": 1766782199,
        "submit_start_date": 1455780600,
        "current": 1537435426
    },
    "problem_author_html_handle": "<span \n            class='rating' \n            style='display: inline-block; \n                    font-size: 10px; \n                    background: #1E7D22;\n                    padding: 0 3px; \n                    line-height: 1.3; \n                    color: white;\n                    margin-right: 2px;'>2&#9733;</span><span>sneha_rajeev</span>",
    "problem_name": "Skiplist",
    "source_sizelimit": "50000",
    "tags": "<a class='problem-tag-small ' href='/tags/problems/sneha_rajeev'>sneha_rajeev</a>",
    "problem_tester_html_handle": "",
    "problem_author": "sneha_rajeev",
    "contest_code": "WBY1601",
    "max_timelimit": "1",
    "problem_code": "WBYQ12"
}